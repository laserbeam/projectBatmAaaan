/** @deprecated */
final int UNITSIZE = 24;

/**
 * Level.
 *
 * A State that contains various GameObjects and handles their lifecycle.
 */
class Level extends State {
  /** Size of the level. */
  int w, h;
  /** Rendering offset. */
  int offX, offY;
  /** Map of walls, stored separately from other GameObjects for collision optimizations. */
  Wall[][] map;
  /** A list of GameObjects. */
  Layer entities; // random but OK name for fancy objects contained in a level.
  /** right now just lines go here */
  Layer entities2;
  /** Decoration objects, drawn above everything */
  Layer decorations;
  /** A list of waves. Level handles wave logic, parts of it could be moved to Wave? */
  Layer waves;
  // int countWaves = 0;
  // int curWave = 0;
  /** The current Player. NOTE! The Player is NOT stored in this.entities! */
  Player currentPlayer;
  UserInterface ui;
  boolean _levelEnding = false;
  boolean _levelStarting = true;
  float _overlayAlpha = 255;

  /**
   * Creates an empty level.
   *
   * Level initialization is delegated to LevelFactory, code is long and horrid and I want to keep it out of here.
   * @param w: Width of the level.
   * @param h: Height of the level.
   * @deprecated, this method should only be used for testing.
   */
  Level( int w, int h ) {
    LEVEL_FACTORY.initLevel( this, w, h );
    adjustViewOffset( getScreenXY(currentPlayer) );
  }
  
  /**
   * Creates an empty level from a file.
   *
   * Level initialization is delegated to LevelFactory, code is long and horrid and I want to keep it out of here.
   * @param filename: Path to an XML file generated by Tiled.
   */
  Level( String filename ) {
    LEVEL_FACTORY.initLevel( this, filename );
    adjustViewOffset( getScreenXY(currentPlayer) );
    name = filename;
    METRICS_LOGGER.logNewLevel(this);
  }

  /**
   * Process input events.
   */
  void input() {
    InputEvent e = InputManager.getEvent();
    while ( e != null ) {
      switch ( e.code ) {
        case EV_MOVE:
          currentPlayer.move( e.x, e.y );
          PVector newXY = getScreenXY( currentPlayer );
          adjustViewOffset( newXY.x, newXY.y );
          break;
        case EV_ROTATE:
          currentPlayer.dir = e.x;
          break;
        case EV_ACTION_TRIGGER:
          // println(" "+e.x+" "+e.y);
          if (_levelEnding) break;
          float waveEnergy = map( e.x, 0, 1, 0.3, 0.6+(e.y/(1/0.4)) );
          float waveAngle = map( e.y, 0, 1, radians(140+e.x*20), radians(20+e.x*20) );
          float waveRange = map( e.y, 0, 1, 200, 400 );
          // if (e.y < 0.3) { waveRange = 200; waveAngle = radians(140+e.x*20); }
          if ( currentPlayer.drainEnergy( waveEnergy ) ) {
            Wave w = spawnWave( currentPlayer.x, currentPlayer.y, currentPlayer.dir, waveAngle, waveRange );
            w.setEnergy( waveEnergy );
            ui.waveSpawned( waveEnergy );
          }
          break;
        case EV_END_STATE:
          METRICS_LOGGER.logExitLevel(this);
          StateManager.popState();
          break;
        case EV_EXIT_GAME:
          METRICS_LOGGER.logExitLevel(this);
          exit();
          break;
      }
      e = InputManager.getEvent();
    }
  }

  /**
   * Update the State.
   */
  void update() {
    updateGameObjects();
    for ( int x = 0; x<w; x++ ){
      for ( int y = 0; y<h; y++ ){
        if ( map[x][y] == null ) continue;
        map[x][y].update();
        if ( map[x][y].isDead ) { map[x][y] = null; continue; }
        for ( int i = 0; i < waves.size(); i++ ) {
          Wave w = (Wave) waves.get(i);
          if ( w.collidesGameObject( map[x][y] )) {
            map[x][y].lightUp( w.energy );
            break;
          }
        }
      }
    }
    currentPlayer.update();
    for ( int j = 0; j < waves.size(); j++ ) {
      Wave w = (Wave) waves.get(j);
      for ( int i = 0; i < entities.size(); i++ ) {
        GameObject e = entities.get(i);
        if ( w.collidesGameObject( e )) {
          e.lightUp( w.energy );
          break;
        }
      }
      for ( int i = 0; i < entities2.size(); i++ ) {
        GameObject e = entities2.get(i);
        if ( w.collidesGameObject( e )) {
          e.lightUp( w.energy );
          break;
        }
      }
    }
    if (_levelEnding) {
      _overlayAlpha += 4;
      if (_overlayAlpha >= 255) {
        METRICS_LOGGER.logFinishLevel(this);
        StateManager.swapState( LEVEL_MANAGER.nextLevel( this.name ) );
      }
    }
    if (_levelStarting) {
      _overlayAlpha -= 7;
      if (_overlayAlpha <= 0) {
        _overlayAlpha = 0;
        _levelStarting = false;
      }
    }
    METRICS_LOGGER.logGameState(this);
  }

  /**
   * Update all the GameObjects (except for the Player, he's special).
   * This just calls update() on everything and removes dead GameObjects.
   */
  void updateGameObjects() {
    GameObject ent;
    waves.update();
    entities.update();
    entities2.update();
    decorations.update();

  }

  /**
   * Draw one frame.
   */
  void draw() {
    background( 0 );
    drawWalls();
    currentPlayer.draw( offX, offY );
    entities.draw( offX, offY );
    entities2.draw( offX, offY );
    waves.draw( offX, offY );
    decorations.draw( offX, offY );
    if ( _levelEnding || _levelStarting ) {
      fill( 0, 0, 0, _overlayAlpha );
      rect( width/2, height/2, width, height );
    }
    ui.draw( currentPlayer );
    if ( DEBUG_MODE ) {
      fill(255);
      text("Player: " + currentPlayer.x + " " + currentPlayer.y, 2, 20);
    }
  }

  Wave spawnWave( float x, float y ) {
    return spawnWave( x, y, atan2( mouseY-offY-y, mouseX-offX-x ));
  }

  Wave spawnWave( float x, float y, float dir ) {
    Wave w = new Wave( x, y, dir );
    waves.add( w );
    return w;
  }

  Wave spawnWave( float x, float y, float dir, float limit ) {
    Wave w = new Wave( x, y, dir, limit );
    waves.add( w );
    return w;
  }

  /**
   * Spawn a wave in the level.
   * @param x: X coordinate of the center.
   * @param y: Y coordinate of the center.
   * @param dir: The direction of the wave (radians).
   * @param theta: The angle of the wave (radians).
   * @param limit: The maximum range of the wave. 
   */
  Wave spawnWave( float x, float y, float dir, float theta, float limit ) {
    Wave w = new Wave( x, y, dir, theta, limit );
    waves.add( w );
    return w;
  }

  /**
   * Render all the walls.
   */
  void drawWalls() {
    noStroke();
    int draw_cell_start_x, draw_cell_start_y;
    int draw_cell_end_x, draw_cell_end_y;
    int draw_cell_count;
    draw_cell_start_x = min(w,max(0,-offX/WALLSIZE));
    draw_cell_start_y = min(h,max(0,-offY/WALLSIZE));
    draw_cell_end_x = max(0,min(w,draw_cell_start_x+(width/WALLSIZE)+2));
    draw_cell_end_y = max(0,min(h,draw_cell_start_y+(height/WALLSIZE)+2));
    //draw_cell_count = 0;
    for ( int x = draw_cell_start_x; x<draw_cell_end_x; x++ ) {
      for ( int y = draw_cell_start_y; y<draw_cell_end_y; y++ ) {
        //draw_cell_count += 1;
        if ( map[x][y] != null ) {
          map[x][y].draw( offX, offY );
        }
      }
    }
    //println(str(draw_cell_count));
  }

  // NOT USED, STAYS COMMENTED FOR NOW UNTIL WE MAKE WAVES BOUNCE AROUND
  // void reflectWave( Wave w, Collision c ) {
  //   PVector n = c.normal.get();
  //   n.mult( dist( w.center.x, w.center.y, c.x, c.y) );
  //   Wave mid = new Wave( c.x-n.x, c.y-n.y, c.x, c.y, w.radius, c.normal, w.limit );
  //   waves.add( mid );
  // }


  /**
   * Check for collisions between a level and some simple game object.
   * WARNING! This does not take into account angles in level geometry!
   * @param other: The game object on which to test for collisions.
   * @return: True if a collision takes place.
   */
  boolean collidesSimple( GameObject other ) {
    int ax = (int)( other.x / WALLSIZE );
    int ay = (int)( other.y / WALLSIZE );
    int areaSize = 3+(int)( other.size / WALLSIZE );
    for ( int i = max( 0, ax - areaSize); i < min( w, ax + areaSize ); i++) {
      for ( int j = max( 0, ay - areaSize); j < min( h, ay + areaSize ); j++ ) {
        if ( map[i][j] == null ) continue;
        if ( other.collidesSimple( map[i][j] ) ) return true;
      }
    }
    return false;
  }

  /**
   * Check for precise collision between a level and a circle.
   * This collision is precise and takes level geometry into consideration
   * @param cx: The X coordiante of the circle's center.
   * @param cy: The Y coordiante of the circle's center.
   * @param radius: The radius of the circle.
   * @return: Collision data of the best collision or null if no collision takes place.
   * WARNING! Only returns 1 collision even if the circle hits the level in multiple points.
   */
  Collision collidesWithCircle( float cx, float cy, float radius ) {
    int ax = (int)( cx / WALLSIZE );
    int ay = (int)( cy / WALLSIZE );
    int areaSize = 3+(int)( radius / WALLSIZE );
    Collision minc = null;
    for ( int i = max( 0, ax - areaSize); i < min( w, ax + areaSize ); i++) {
      for ( int j = max( 0, ay - areaSize); j < min( h, ay + areaSize ); j++ ) {
        if ( map[i][j] == null ) continue;
        Collision c = map[i][j].collidesWithCircle( cx, cy, radius );
        if ( c != null ) {
          if ( minc == null || minc.distance > c.distance) {
            minc = c;
          }
          // println("player: " + cx + " " + cy + " " + radius +
          //         " collision: " + c.x + " " + c.y + " " + c.distance + 
          //         " wall: " + map[i][j].x + " " + map[i][j].y);
        }
      }
    }
    return minc;
  }

  // Precise collision checking with a circle in the level
  /**
   * Check for precise collision between a level and a GameObject.
   * This collision is precise and takes level geometry into consideration and
   * assumes the GameObject is a circle.
   * @param other: The GameObject to check collision against.
   * @return: Collision data for the best detected collision or null if no
   * collision takes place.
   */
  Collision collidesWithCircle( GameObject other ) {
    return collidesWithCircle( other.x, other.y, (other.size/2) );
  }

  /**
   * Convert game coordinates to screen coordinates.
   * @param x: Game X coordinate.
   * @param y: Game Y coordinate.
   * @return: PVector with the screen coordinates.
   */
  PVector getScreenXY( float x, float y ) {
    return new PVector( (x + offX)*SCALE_RATIO, (y + offY)*SCALE_RATIO );
  }

  PVector getWorldXY( float x, float y ) {
    return new PVector( (x/SCALE_RATIO)-offX, (y/SCALE_RATIO)-offY );
  }

  /**
   * Convert game coordinates to screen coordinates.
   * @param p: PVector with game coordinates.
   * @return: PVector with the screen coordinates.
   */
  PVector getScreenXY( PVector p ) {
    return getScreenXY( p.x, p.y );
  }

  /**
   * Convert game coordinates to screen coordinates.
   * @param object: A GameObject from which to take the coordinates.
   * @return: PVector with the screen coordinates.
   */
  PVector getScreenXY( GameObject object ) {
    return getScreenXY( object.x, object.y );
  }

  /**
   * Move the level and change its offset.
   * @param x: Distance on the X axis.
   * @param y: Distance on the Y axis.
   */
  void move( float x, float y ) {
    offX += x;
    offY += y;
  }

  final float VIEW_MARGIN_LEFT = 2*width/5;
  final float VIEW_MARGIN_RIGHT = 2*width/5;
  final float VIEW_MARGIN_TOP = 2*height/5;
  final float VIEW_MARGIN_BOTTOM = 2*height/5;
  /**
   * Adjusts the vew based on player position.
   * @param newX: Player SCREEN X coordinate.
   * @param newY: Player SCREEN Y coordinate.
   */
  void adjustViewOffset( float newX, float newY ) {
    if ( newX < VIEW_MARGIN_LEFT ) offX += ( VIEW_MARGIN_LEFT - newX );
    if ( newX > width - VIEW_MARGIN_RIGHT ) offX += ( width - VIEW_MARGIN_RIGHT - newX );
    if ( newY < VIEW_MARGIN_TOP ) offY += ( VIEW_MARGIN_TOP - newY );
    if ( newY > height - VIEW_MARGIN_BOTTOM ) offY += ( height - VIEW_MARGIN_BOTTOM - newY );
  }

  /**
   * Adjusts the vew based on player position.
   * @param p: Player SCREEN coordinate as a vector.
   */  
  void adjustViewOffset( PVector p ) {
    adjustViewOffset( p.x, p.y );
  }
  Player get_currentPlayer() {
    return currentPlayer;
  }

  void finishLevel( float x, float y ) {
    spawnWave( x, y, 0, TWO_PI-0.001, 1000 );
    _levelEnding = true;
  }
};
